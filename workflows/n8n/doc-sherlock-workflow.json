{
  "name": "Doc-Sherlock PDF Analysis",
  "nodes": [
    {
      "parameters": {},
      "id": "f1e2d3c4-b5a6-7890-1234-567890abcdef",
      "name": "Manual Trigger",
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [
        240,
        300
      ]
    },
    {
      "parameters": {
        "filePath": "/home/node/data/sample.pdf",
        "options": {}
      },
      "id": "a1b2c3d4-e5f6-7890-1234-567890abcdef",
      "name": "Read PDF File",
      "type": "n8n-nodes-base.readBinaryFile",
      "typeVersion": 1,
      "position": [
        460,
        300
      ]
    },
    {
      "parameters": {
        "jsCode": "// Manually construct multipart form data without external dependencies\nconst http = require('http');\n\n// Get the PDF binary data\nconst pdfBuffer = Buffer.from($input.first().binary.data.data, 'base64');\n\n// Generate boundary\nconst boundary = '----FormBoundary' + Math.random().toString(36).substring(2);\n\n// Build multipart form data\nconst CRLF = '\\r\\n';\nlet body = '';\nbody += '--' + boundary + CRLF;\nbody += 'Content-Disposition: form-data; name=\"file\"; filename=\"document.pdf\"' + CRLF;\nbody += 'Content-Type: application/pdf' + CRLF + CRLF;\n\n// Convert to buffer and combine\nconst headerBuffer = Buffer.from(body, 'utf8');\nconst footerBuffer = Buffer.from(CRLF + '--' + boundary + '--' + CRLF, 'utf8');\nconst formData = Buffer.concat([headerBuffer, pdfBuffer, footerBuffer]);\n\n// Return a promise for the HTTP request\nreturn new Promise((resolve, reject) => {\n  const options = {\n    hostname: 'host.docker.internal',\n    port: 8000,\n    path: '/analyze',\n    method: 'POST',\n    headers: {\n      'Content-Type': 'multipart/form-data; boundary=' + boundary,\n      'Content-Length': formData.length\n    }\n  };\n\n  const req = http.request(options, (res) => {\n    let data = '';\n    \n    res.on('data', (chunk) => {\n      data += chunk;\n    });\n    \n    res.on('end', () => {\n      try {\n        const response = JSON.parse(data);\n        resolve({\n          json: {\n            response: response,\n            statusCode: res.statusCode\n          }\n        });\n      } catch (error) {\n        resolve({\n          json: {\n            error: 'Failed to parse response',\n            raw_response: data,\n            statusCode: res.statusCode\n          }\n        });\n      }\n    });\n  });\n  \n  req.on('error', (error) => {\n    resolve({\n      json: {\n        error: error.message,\n        statusCode: 0\n      }\n    });\n  });\n  \n  // Send the form data\n  req.write(formData);\n  req.end();\n});"
      },
      "id": "b2c3d4e5-f6a7-8901-2345-67890abcdef1",
      "name": "Send to API",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        680,
        300
      ]
    },
    {
      "parameters": {
        "jsCode": "// Process the API response\nconst data = $input.first().json;\n\nif (data.error) {\n  return {\n    json: {\n      success: false,\n      error: data.error,\n      raw_response: data.raw_response || null\n    }\n  };\n}\n\nconst response = data.response;\n\nif (response && response.findings) {\n  const findings = response.findings;\n  \n  // Create a summary\n  const summary = {\n    total_findings: findings.length,\n    by_severity: {},\n    by_type: {},\n    findings: []\n  };\n  \n  // Process each finding\n  findings.forEach(finding => {\n    // Count by severity\n    summary.by_severity[finding.severity] = \n      (summary.by_severity[finding.severity] || 0) + 1;\n    \n    // Count by type\n    const findingType = finding.finding_type || finding.type;\n    summary.by_type[findingType] = \n      (summary.by_type[findingType] || 0) + 1;\n    \n    // Add simplified finding info\n    summary.findings.push({\n      type: findingType,\n      severity: finding.severity,\n      page: finding.page_number,\n      description: finding.description,\n      location: finding.location\n    });\n  });\n  \n  return {\n    json: {\n      success: true,\n      analysis_summary: summary,\n      raw_response: response\n    }\n  };\n} else if (response && response.error) {\n  // Handle error response\n  return {\n    json: {\n      success: false,\n      error: response.error,\n      message: \"API returned an error\"\n    }\n  };\n}\n\n// No findings or unexpected response\nreturn {\n  json: {\n    success: false,\n    error: \"Unexpected response format\",\n    raw_response: response\n  }\n};"
      },
      "id": "d4e5f6a7-b8c9-0123-4567-890abcdef123",
      "name": "Process Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        900,
        300
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "e5f6a7b8-c9d0-1234-5678-90abcdef1234",
              "leftValue": "={{ $json.success }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equal"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "e5f6a7b8-c9d0-1234-5678-90abcdef1234",
      "name": "Check Success",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1120,
        300
      ]
    },
    {
      "parameters": {
        "jsCode": "// Format successful analysis results for display\nconst data = $input.first().json;\nconst summary = data.analysis_summary;\n\nlet output = `üîç Doc-Sherlock Analysis Results\\n`;\noutput += `================================\\n\\n`;\noutput += `üìä Summary:\\n`;\noutput += `- Total Findings: ${summary.total_findings}\\n\\n`;\n\nif (summary.total_findings > 0) {\n  output += `üìà By Severity:\\n`;\n  Object.entries(summary.by_severity).forEach(([severity, count]) => {\n    const emoji = severity === 'HIGH' ? 'üî¥' : severity === 'MEDIUM' ? 'üü°' : 'üü¢';\n    output += `  ${emoji} ${severity}: ${count}\\n`;\n  });\n  \n  output += `\\nüè∑Ô∏è By Type:\\n`;\n  Object.entries(summary.by_type).forEach(([type, count]) => {\n    output += `  ‚Ä¢ ${type}: ${count}\\n`;\n  });\n  \n  output += `\\nüìã Detailed Findings:\\n`;\n  summary.findings.forEach((finding, index) => {\n    output += `\\n${index + 1}. ${finding.type}\\n`;\n    output += `   Severity: ${finding.severity}\\n`;\n    output += `   Page: ${finding.page}\\n`;\n    output += `   Description: ${finding.description}\\n`;\n    if (finding.location) {\n      output += `   Location: (${finding.location.x.toFixed(3)}, ${finding.location.y.toFixed(3)})\\n`;\n    }\n  });\n} else {\n  output += `‚úÖ No security issues detected in the PDF!\\n`;\n}\n\nreturn {\n  json: {\n    formatted_results: output,\n    summary: summary\n  }\n};"
      },
      "id": "f6a7b8c9-d0e1-2345-6789-0abcdef12345",
      "name": "Format Success Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1340,
        240
      ]
    },
    {
      "parameters": {
        "jsCode": "// Format error results for display\nconst data = $input.first().json;\n\nlet output = `‚ùå Doc-Sherlock Analysis Error\\n`;\noutput += `===============================\\n\\n`;\noutput += `Error: ${data.error}\\n`;\nif (data.message) {\n  output += `Message: ${data.message}\\n`;\n}\nif (data.raw_response) {\n  output += `\\nRaw Response:\\n${JSON.stringify(data.raw_response, null, 2)}\\n`;\n}\n\nreturn {\n  json: {\n    formatted_results: output,\n    error: data.error\n  }\n};"
      },
      "id": "a7b8c9d0-e1f2-3456-7890-abcdef123456",
      "name": "Format Error Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1340,
        360
      ]
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "doc-sherlock",
        "options": {}
      },
      "id": "b8c9d0e1-f2a3-4567-8901-bcdef1234567",
      "name": "Webhook Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [
        240,
        500
      ],
      "webhookId": "doc-sherlock-webhook"
    },
    {
      "parameters": {
        "jsCode": "// Process incoming webhook file upload\nconst body = $input.first().json.body;\nconst files = $input.first().json.files;\n\n// Check if file was uploaded\nif (!files || !files.file) {\n  return {\n    json: {\n      error: \"No file uploaded\",\n      message: \"Please upload a PDF file\"\n    }\n  };\n}\n\nconst file = files.file;\n\n// Validate file type\nif (!file.mimetype || !file.mimetype.includes('pdf')) {\n  return {\n    json: {\n      error: \"Invalid file type\",\n      message: \"Only PDF files are supported\"\n    }\n  };\n}\n\n// Pass the file buffer directly\nreturn {\n  json: {\n    filename: file.originalname || 'uploaded.pdf',\n    filesize: file.size\n  },\n  binary: {\n    data: {\n      data: file.buffer.toString('base64'),\n      mimeType: file.mimetype,\n      fileName: file.originalname || 'uploaded.pdf'\n    }\n  }\n};"
      },
      "id": "c9d0e1f2-a3b4-5678-9012-cdef12345678",
      "name": "Process Upload",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        460,
        500
      ]
    },
    {
      "parameters": {
        "jsCode": "// Manually construct multipart form data for webhook upload\nconst http = require('http');\n\n// Get the PDF binary data\nconst pdfBuffer = Buffer.from($input.first().binary.data.data, 'base64');\nconst filename = $input.first().json.filename;\n\n// Generate boundary\nconst boundary = '----FormBoundary' + Math.random().toString(36).substring(2);\n\n// Build multipart form data\nconst CRLF = '\\r\\n';\nlet body = '';\nbody += '--' + boundary + CRLF;\nbody += `Content-Disposition: form-data; name=\"file\"; filename=\"${filename}\"` + CRLF;\nbody += 'Content-Type: application/pdf' + CRLF + CRLF;\n\n// Convert to buffer and combine\nconst headerBuffer = Buffer.from(body, 'utf8');\nconst footerBuffer = Buffer.from(CRLF + '--' + boundary + '--' + CRLF, 'utf8');\nconst formData = Buffer.concat([headerBuffer, pdfBuffer, footerBuffer]);\n\n// Return a promise for the HTTP request\nreturn new Promise((resolve, reject) => {\n  const options = {\n    hostname: 'host.docker.internal',\n    port: 8000,\n    path: '/analyze',\n    method: 'POST',\n    headers: {\n      'Content-Type': 'multipart/form-data; boundary=' + boundary,\n      'Content-Length': formData.length\n    }\n  };\n\n  const req = http.request(options, (res) => {\n    let data = '';\n    \n    res.on('data', (chunk) => {\n      data += chunk;\n    });\n    \n    res.on('end', () => {\n      try {\n        const response = JSON.parse(data);\n        \n        if (response && response.findings) {\n          const findings = response.findings;\n          \n          resolve({\n            json: {\n              success: true,\n              total_findings: findings.length,\n              findings: findings.map(finding => ({\n                type: finding.finding_type || finding.type,\n                severity: finding.severity,\n                page: finding.page_number,\n                description: finding.description,\n                location: finding.location\n              }))\n            }\n          });\n        } else {\n          resolve({\n            json: {\n              success: false,\n              error: \"Analysis failed\",\n              message: \"Unable to analyze the PDF file\",\n              raw_response: response\n            }\n          });\n        }\n      } catch (error) {\n        resolve({\n          json: {\n            success: false,\n            error: 'Failed to parse response',\n            message: data\n          }\n        });\n      }\n    });\n  });\n  \n  req.on('error', (error) => {\n    resolve({\n      json: {\n        success: false,\n        error: error.message,\n        message: \"Connection failed\"\n      }\n    });\n  });\n  \n  // Send the form data\n  req.write(formData);\n  req.end();\n});"
      },
      "id": "d0e1f2a3-b4c5-6789-0123-def123456789",
      "name": "Analyze Uploaded PDF",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        680,
        500
      ]
    }
  ],
  "connections": {
    "Manual Trigger": {
      "main": [
        [
          {
            "node": "Read PDF File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Read PDF File": {
      "main": [
        [
          {
            "node": "Send to API",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send to API": {
      "main": [
        [
          {
            "node": "Process Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Response": {
      "main": [
        [
          {
            "node": "Check Success",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Success": {
      "main": [
        [
          {
            "node": "Format Success Results",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Format Error Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Webhook Trigger": {
      "main": [
        [
          {
            "node": "Process Upload",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Upload": {
      "main": [
        [
          {
            "node": "Analyze Uploaded PDF",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [
    {
      "createdAt": "2024-01-01T00:00:00.000Z",
      "updatedAt": "2024-01-01T00:00:00.000Z",
      "id": "doc-sherlock",
      "name": "doc-sherlock"
    }
  ],
  "triggerCount": 2,
  "updatedAt": "2024-01-01T00:00:00.000Z",
  "versionId": "1"
}